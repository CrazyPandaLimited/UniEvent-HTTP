#include "http.h"
#ifndef _WIN32
    #include <pthread.h>
#endif

namespace panda { namespace unievent { namespace http {

static thread_local LoopSP sync_loop;
static thread_local Pool*  sync_pool;

static bool _init () {
    #ifndef _WIN32
    pthread_atfork(nullptr, nullptr, []{ sync_loop->handle_fork(); });
    #endif
    return true;
}
static const bool __init = _init();

expected<ResponseSP, std::error_code> http_request (const RequestSP& req, sync_t) {
    auto pool = sync_pool;
    if (!pool) {
        sync_loop = new Loop();
        pool = sync_pool = Pool::instance(sync_loop);
    }
    
    expected<ResponseSP, std::error_code> ret;
    req->response_event.add([&ret](auto&, auto& res, auto& err) {
        if (err) ret = make_unexpected(err);
        else     ret = res;
    });
    
    auto loop = pool->loop();
    loop->run_nowait(); // catch all EOFs from timed out keep-alive connections, otherwise current request may catch false-positive EOF
    pool->request(req);
    loop->run(); // ue-http must have no event leaks or run() will never complete
    
    return ret;
}

expected<string, std::error_code> http_get (const URISP& uri) {
    auto req = Request::Builder().uri(uri).method(Request::Method::GET).build();
    return http_request(req, sync_t()).map([](const ResponseSP& res) {
        return res->body.to_string();
    });
}

}}}